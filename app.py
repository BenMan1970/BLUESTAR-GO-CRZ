
"""
BlueStar Institutional - v2.7 (Clean & Optimized)
Author: Generated by ChatGPT
Notes:
- Expects OANDA access token in streamlit secrets: st.secrets["OANDA_ACCESS_TOKEN"]
- Designed to run as a Streamlit app.
- Save as BlueStarInstitutional_v2_7.py and run: streamlit run BlueStarInstitutional_v2_7.py
"""

import streamlit as st
import pandas as pd
import numpy as np
import pytz
from datetime import datetime
from dataclasses import dataclass
from typing import List, Optional
from enum import Enum
import logging
import time
from io import BytesIO
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib import colors
from reportlab.lib.units import mm

# OANDA client
try:
    from oandapyV20 import API
    from oandapyV20.endpoints.instruments import InstrumentsCandles
except Exception:
    API = None
    InstrumentsCandles = None

# === Branding / Config ===
APP_NAME = "BlueStar Institutional"
APP_VERSION = "v2.7"

st.set_page_config(page_title=APP_NAME, layout="wide", initial_sidebar_state="expanded")

logging.basicConfig(level=logging.INFO, format='%(asctime)s | %(levelname)s | %(message)s')
logger = logging.getLogger("BlueStar")

PAIRS_DEFAULT = [
    "EUR_USD","GBP_USD","USD_JPY","USD_CHF","AUD_USD","NZD_USD","USD_CAD",
    "EUR_GBP","EUR_JPY","GBP_JPY","AUD_JPY","CAD_JPY","NZD_JPY",
    "EUR_AUD","EUR_CAD","EUR_NZD","GBP_AUD","GBP_CAD","GBP_NZD",
    "AUD_CAD","AUD_NZD","CAD_CHF","CHF_JPY","AUD_CHF","NZD_CHF",
    "EUR_CHF","GBP_CHF","USD_SEK",
    "XAU_USD","XPT_USD",
    "US30_USD","NAS100_USD","SPX500_USD"
]
GRANULARITY_MAP = {"H1": "H1", "H4": "H4", "D1": "D"}
_MIN_REQUEST_INTERVAL = 0.20
_last_request_time = {"t": 0.0}

# === Data classes ===
class SignalQuality(Enum):
    INSTITUTIONAL = "Institutional"
    PREMIUM = "Premium"
    STANDARD = "Standard"

@dataclass
class TradingParams:
    atr_sl_multiplier: float = 2.0
    atr_tp_multiplier: float = 3.0
    min_adx_threshold: int = 20
    adx_strong_threshold: int = 25
    min_rr_ratio: float = 1.2
    cascade_required: bool = True
    strict_flip_only: bool = True

@dataclass
class RiskConfig:
    max_risk_per_trade: float = 0.01
    kelly_fraction: float = 0.25

@dataclass
class Signal:
    timestamp: datetime
    pair: str
    timeframe: str
    action: str
    entry_price: float
    stop_loss: float
    take_profit: float
    score: int
    quality: SignalQuality
    position_size: float
    risk_amount: float
    risk_reward: float
    adx: float
    rsi: float
    atr: float
    higher_tf_trend: str
    is_live: bool
    is_fresh_flip: bool
    is_strict_flip: bool

# === OANDA client ===
@st.cache_resource
def get_oanda_client():
    token = st.secrets.get("OANDA_ACCESS_TOKEN")
    if not token:
        logger.error("OANDA access token missing in st.secrets.")
        return None
    if API is None:
        logger.error("oandapyV20 library is not available.")
        return None
    return API(access_token=token)

_client = get_oanda_client()

# === Helpers ===
def _throttle():
    elapsed = time.time() - _last_request_time["t"]
    if elapsed < _MIN_REQUEST_INTERVAL:
        time.sleep(_MIN_REQUEST_INTERVAL - elapsed)
    _last_request_time["t"] = time.time()

@st.cache_data(ttl=20, show_spinner=False)
def get_candles(pair: str, tf: str, count: int = 300) -> pd.DataFrame:
    gran = GRANULARITY_MAP.get(tf)
    if not gran:
        logger.warning("Invalid timeframe requested: %s", tf)
        return pd.DataFrame()
    if _client is None or InstrumentsCandles is None:
        logger.error("OANDA client or InstrumentsCandles not available.")
        return pd.DataFrame()
    try:
        _throttle()
        params = {"granularity": gran, "count": count, "price": "M"}
        req = InstrumentsCandles(instrument=pair, params=params)
        resp = _client.request(req)
        candles = resp.get("candles", [])
        rows = []
        for c in candles:
            mid = c.get("mid") or c.get("bid") or c.get("ask")
            if not mid:
                continue
            rows.append({
                "time": pd.to_datetime(c["time"]),
                "open": float(mid["o"]),
                "high": float(mid["h"]),
                "low": float(mid["l"]),
                "close": float(mid["c"]),
                "complete": c.get("complete", False)
            })
        if not rows:
            return pd.DataFrame()
        df = pd.DataFrame(rows)
        # normalize tz
        if df["time"].dt.tz is not None:
            df["time"] = df["time"].dt.tz_convert(None)
        df = df.reset_index(drop=True)
        return df
    except Exception as e:
        logger.exception("Error fetching candles for %s: %s", pair, e)
        return pd.DataFrame()

def calculate_indicators(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or df.empty or len(df) < 50:
        return df
    df = df.copy()
    close = df["close"]
    high = df["high"]
    low = df["low"]

    def wma(series: pd.Series, length: int) -> pd.Series:
        if len(series) < length:
            return pd.Series([np.nan]*len(series), index=series.index)
        weights = np.arange(1, length+1)
        denom = weights.sum()
        return series.rolling(length).apply(lambda x: np.dot(x, weights)/denom, raw=True)

    n = 20
    wma_half = wma(close, n//2)
    wma_full = wma(close, n)
    df["hma"] = wma(2 * wma_half - wma_full, int(np.sqrt(n)))
    df["hma_up"] = df["hma"] > df["hma"].shift(1)

    # RSI (7)
    delta = close.diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    roll_up = up.ewm(alpha=1/7, min_periods=7).mean()
    roll_down = down.ewm(alpha=1/7, min_periods=7).mean()
    rs = roll_up / roll_down.replace(0, np.nan)
    df["rsi"] = 100 - (100 / (1 + rs))

    # True range & ATR
    tr = pd.concat([
        (high - low).abs(),
        (high - close.shift(1)).abs(),
        (low - close.shift(1)).abs()
    ], axis=1).max(axis=1)
    atr14 = tr.ewm(alpha=1/14, min_periods=14).mean()
    df["atr_val"] = atr14

    # DI/ADX
    plus_dm = high.diff().clip(lower=0)
    minus_dm = -low.diff().clip(upper=0)
    plus_di = 100 * (plus_dm.ewm(alpha=1/14, min_periods=14).mean() / atr14.replace(0, np.nan))
    minus_di = 100 * (minus_dm.ewm(alpha=1/14, min_periods=14).mean() / atr14.replace(0, np.nan))
    dx = 100 * (plus_di - minus_di).abs() / (plus_di + minus_di).replace(0, np.nan)
    df["adx"] = dx.ewm(alpha=1/14, min_periods=14).mean().fillna(0)

    # UT trailing stop (vectorized loop)
    close_vals = close.to_numpy()
    atr_loss = (2.0 * atr14).fillna(method="bfill").to_numpy()
    nrows = len(df)
    trailing = np.zeros(nrows, dtype=float)
    trailing[0] = close_vals[0] - atr_loss[0]
    for i in range(1, nrows):
        prev_stop = trailing[i-1]
        cur = close_vals[i]
        loss = atr_loss[i]
        if (cur > prev_stop) and (close_vals[i-1] > prev_stop):
            trailing[i] = max(prev_stop, cur - loss)
        elif (cur < prev_stop) and (close_vals[i-1] < prev_stop):
            trailing[i] = min(prev_stop, cur + loss)
        elif cur > prev_stop:
            trailing[i] = cur - loss
        else:
            trailing[i] = cur + loss
    df["ut_trailing"] = trailing
    df["ut_state"] = np.where(df["close"].to_numpy() > trailing, 1, -1)

    return df

@st.cache_data(ttl=300)
def get_trend_alignment(pair: str, signal_tf: str) -> str:
    mapping = {"H1": "H4", "H4": "D1", "D1": "W"}
    higher_tf = mapping.get(signal_tf)
    if not higher_tf:
        return "Neutral"
    df = get_candles(pair, higher_tf, 120)
    if df.empty or len(df) < 50:
        return "Neutral"
    df = calculate_indicators(df)
    if df["hma"].isna().all() or len(df) < 2:
        return "Neutral"
    curr = df["hma"].iloc[-1]
    prev = df["hma"].iloc[-2]
    if curr > prev:
        return "Bullish"
    if curr < prev:
        return "Bearish"
    return "Neutral"

def analyze_pair(pair: str, tf: str, mode_live: bool, risk_manager, params: TradingParams) -> Optional[Signal]:
    df = get_candles(pair, tf, 300)
    if df is None or len(df) < 100:
        return None
    df = calculate_indicators(df)

    if mode_live:
        idx = -1
    else:
        idx = -1 if df.iloc[-1].get("complete", True) else -2

    if abs(idx) >= len(df):
        return None

    last = df.iloc[idx]
    prev = df.iloc[idx-1]
    prev2 = df.iloc[idx-2]

    if pd.isna(last.get("hma")) or pd.isna(prev.get("hma")) or pd.isna(prev2.get("hma")):
        return None
    if pd.isna(last.get("rsi")) or pd.isna(last.get("adx")):
        return None

    hma_flip_green = bool(last.hma_up and (not prev.hma_up))
    hma_flip_red = bool((not last.hma_up) and prev.hma_up)
    hma_extended_green = bool(last.hma_up and prev.hma_up and (not prev2.hma_up) and not hma_flip_green)
    hma_extended_red = bool((not last.hma_up) and (not prev.hma_up) and prev2.hma_up and not hma_flip_red)

    is_strict = False
    raw_buy = False
    raw_sell = False

    if params.strict_flip_only:
        if hma_flip_green and last.rsi > 50 and last.ut_state == 1:
            raw_buy, is_strict = True, True
        elif hma_flip_red and last.rsi < 50 and last.ut_state == -1:
            raw_sell, is_strict = True, True
    else:
        if (hma_flip_green or hma_extended_green) and last.rsi > 50 and last.ut_state == 1:
            raw_buy = True
            is_strict = hma_flip_green
        elif (hma_flip_red or hma_extended_red) and last.rsi < 50 and last.ut_state == -1:
            raw_sell = True
            is_strict = hma_flip_red

    if not (raw_buy or raw_sell):
        return None

    action = "BUY" if raw_buy else "SELL"
    higher_trend = get_trend_alignment(pair, tf)
    if params.cascade_required:
        if action == "BUY" and higher_trend == "Bearish":
            return None
        if action == "SELL" and higher_trend == "Bullish":
            return None

    score = 70
    adx_val = float(last.adx) if not pd.isna(last.adx) else 0.0
    if adx_val > params.adx_strong_threshold:
        score += 15
    elif adx_val > params.min_adx_threshold:
        score += 10
    else:
        score -= 5
    score += 15 if is_strict else 5
    rsi_val = float(last.rsi) if not pd.isna(last.rsi) else 50.0
    if action == "BUY" and 50 < rsi_val < 65:
        score += 5
    if action == "SELL" and 35 < rsi_val < 50:
        score += 5
    if (action == "BUY" and higher_trend == "Bullish") or (action == "SELL" and higher_trend == "Bearish"):
        score += 10
    score = max(0, min(100, int(score)))
    quality = SignalQuality.INSTITUTIONAL if score >= 90 else SignalQuality.PREMIUM if score >= 80 else SignalQuality.STANDARD

    atr = float(last.atr_val) if not pd.isna(last.atr_val) else 0.0
    if action == "BUY":
        sl = float(last.close) - params.atr_sl_multiplier * atr
        tp = float(last.close) + params.atr_tp_multiplier * atr
    else:
        sl = float(last.close) + params.atr_sl_multiplier * atr
        tp = float(last.close) - params.atr_tp_multiplier * atr

    rr = abs(tp - float(last.close)) / (abs(float(last.close) - sl) if abs(float(last.close) - sl) > 0 else np.nan)
    if np.isnan(rr) or rr < params.min_rr_ratio:
        return None

    tunis_tz = pytz.timezone("Africa/Tunis")
    ts = pd.to_datetime(last.time) if "time" in last else datetime.utcnow()
    ts = pytz.utc.localize(pd.to_datetime(ts)).astimezone(tunis_tz) if ts.tzinfo is None else ts.astimezone(tunis_tz)

    sig = Signal(
        timestamp=ts,
        pair=pair,
        timeframe=tf,
        action=action,
        entry_price=float(last.close),
        stop_loss=float(sl),
        take_profit=float(tp),
        score=score,
        quality=quality,
        position_size=0.0,
        risk_amount=0.0,
        risk_reward=float(rr),
        adx=int(adx_val),
        rsi=int(rsi_val),
        atr=atr,
        higher_tf_trend=higher_trend,
        is_live=(mode_live and not bool(df.iloc[-1].get("complete", True))),
        is_fresh_flip=is_strict,
        is_strict_flip=is_strict
    )
    return sig

class RiskManager:
    def __init__(self, config: RiskConfig, balance: float):
        self.config = config
        self.balance = float(balance)

    def calculate_position_size(self, signal: Signal) -> float:
        pip_risk = abs(signal.entry_price - signal.stop_loss)
        if pip_risk <= 0 or signal.entry_price <= 0:
            return 0.0
        risk_amount = self.balance * min(max(self.config.max_risk_per_trade, 0.0001), 1.0)
        size_by_risk = risk_amount / pip_risk
        win_rate = 0.55
        expected_rr = signal.risk_reward if signal.risk_reward > 0 else 1.0
        kelly = (win_rate * expected_rr - (1 - win_rate)) / expected_rr if expected_rr > 0 else 0.0
        kelly_adj = max(0.0, min(kelly, 0.25)) * self.config.kelly_fraction
        size = size_by_risk * (1.0 + kelly_adj)
        return round(size, 2)

def run_scan_sequential(pairs: List[str], tfs: List[str], mode_live: bool, risk_manager: RiskManager, params: TradingParams):
    signals: List[Signal] = []
    total = max(1, len(pairs) * len(tfs))
    progress = st.progress(0)
    step = 0
    for pair in pairs:
        for tf in tfs:
            step += 1
            progress.progress(step / total)
            try:
                s = analyze_pair(pair, tf, mode_live, risk_manager, params)
                if s:
                    s.position_size = risk_manager.calculate_position_size(s)
                    s.risk_amount = abs(s.entry_price - s.stop_loss) * s.position_size
                    signals.append(s)
            except Exception:
                logger.exception("Error analyzing %s %s", pair, tf)
                continue
    progress.empty()
    return signals

def generate_pdf(signals: List[Signal]) -> bytes:
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=15 * mm)
    elements = []
    styles = getSampleStyleSheet()
    elements.append(Paragraph(f"<b>{APP_NAME} - Report</b>", styles["Title"]))
    elements.append(Spacer(1, 5 * mm))
    now = datetime.now(pytz.timezone("Africa/Tunis")).strftime("%d/%m/%Y %H:%M")
    elements.append(Paragraph(f"G√©n√©r√© le: {now} (TUNIS)", styles["Normal"]))
    elements.append(Spacer(1, 6 * mm))
    data = [["Time", "Pair", "TF", "Qual", "Dir", "Price", "SL", "TP", "Scr", "R:R"]]
    for s in sorted(signals, key=lambda x: x.score, reverse=True):
        data.append([
            s.timestamp.strftime("%H:%M"),
            s.pair.replace("_", "/"),
            s.timeframe,
            s.quality.value[:4],
            s.action,
            f"{s.entry_price:.4f}",
            f"{s.stop_loss:.4f}",
            f"{s.take_profit:.4f}",
            str(s.score),
            f"{s.risk_reward:.1f}"
        ])
    t = Table(data)
    t.setStyle(TableStyle([
        ("BACKGROUND", (0, 0), (-1, 0), colors.HexColor("#1a1f3a")),
        ("TEXTCOLOR", (0, 0), (-1, 0), colors.HexColor("#00ff88")),
        ("GRID", (0, 0), (-1, -1), 0.5, colors.grey),
        ("FONTSIZE", (0, 0), (-1, -1), 8),
        ("ALIGN", (0, 0), (-1, -1), "CENTER"),
    ]))
    elements.append(t)
    doc.build(elements)
    return buffer.getvalue()

# === UI ===
def main():
    col_title, col_time = st.columns([3, 1])
    with col_title:
        st.markdown(f"# {APP_NAME} {APP_VERSION}")
        st.markdown('<span class="institutional-badge">BLUESTAR INSTITUTIONAL ‚Ä¢ ALL ASSETS</span>', unsafe_allow_html=True)
    with col_time:
        now_tunis = datetime.now(pytz.timezone("Africa/Tunis"))
        is_open = 0 <= now_tunis.weekday() <= 4
        st.markdown(f"""
        <div style='text-align: right; background: rgba(255,255,255,0.05); padding: 8px; border-radius: 6px;'>
            <div style='color: #a0a0c0; font-size: 0.8rem;'>TUNIS TIME</div>
            <div style='font-size: 1.2rem; font-weight: bold; color: white;'>{now_tunis.strftime('%H:%M')}</div>
            <div style='color: {'#00ff88' if is_open else '#ff4b4b'}; font-size: 0.7rem;'>{'‚óè MARKET OPEN' if is_open else '‚óè MARKET CLOSED'}</div>
        </div>
        """, unsafe_allow_html=True)
    st.divider()
    with st.sidebar:
        st.header("‚öôÔ∏è Configuration")
        with st.expander("Scan Settings", expanded=True):
            scan_mode = st.radio("Mode", ["CONFIRMED (Cl√¥ture)", "LIVE (Temps r√©el)"], index=0)
            selected_tfs = st.multiselect("Timeframes", ["H1", "H4", "D1"], default=["H1", "H4"])
            all_pairs = st.checkbox("Toutes les paires/actifs", value=True)
            if all_pairs:
                selected_pairs = PAIRS_DEFAULT
                st.caption(f"‚úÖ {len(PAIRS_DEFAULT)} actifs s√©lectionn√©s (Indices inclus)")
            else:
                selected_pairs = st.multiselect("Paires", PAIRS_DEFAULT, default=["EUR_USD", "XAU_USD", "US30_USD"])
        with st.expander("Risk Manager", expanded=False):
            balance = st.number_input("Capital", value=10000.0)
            risk_pct = st.slider("Risk %", 0.5, 5.0, 1.0) / 100.0
        with st.expander("Filtres Techniques", expanded=True):
            strict_flip = st.checkbox("Strict Flips Only", value=True)
            cascade_on = st.checkbox("Cascade Tendance", value=True)
            min_score = st.slider("Score Min", 0, 100, 60)
        st.markdown("---")
        launch = st.button("LANCER LE SCANNER", type="primary")

    if launch:
        if not selected_pairs or not selected_tfs:
            st.warning("Selectionnez au moins une paire et un TF.")
            return
        mode_live_bool = "LIVE" in scan_mode
        params = TradingParams(strict_flip_only=strict_flip, cascade_required=cascade_on)
        risk_mgr = RiskManager(RiskConfig(max_risk_per_trade=risk_pct), balance)
        signals = run_scan_sequential(selected_pairs, selected_tfs, mode_live_bool, risk_mgr, params)
        signals = [s for s in signals if s.score >= min_score]
        if not signals:
            st.info("Aucun signal d√©tect√©. Essayez de d√©cocher 'Strict Flips Only' ou changez de TF.")
        else:
            st.success(f"{len(signals)} opportunit√©s trouv√©es !")
            kpi1, kpi2, kpi3 = st.columns(3)
            best_sig = max(signals, key=lambda s: s.score)
            kpi1.metric("Opportunit√©s", len(signals))
            kpi2.metric("Meilleur Score", best_sig.score)
            kpi3.metric("Top Asset", best_sig.pair.replace("_", "/"))
            st.markdown("### üìã Signaux D√©tect√©s")
            df_view = pd.DataFrame([{
                "Heure": s.timestamp.strftime("%H:%M"),
                "Paire": s.pair.replace("_", "/"),
                "TF": s.timeframe,
                "Action": s.action,
                "Prix": s.entry_price,
                "Score": s.score,
                "Type": "Strict" if s.is_strict_flip else "Extend",
                "R:R": s.risk_reward
            } for s in sorted(signals, key=lambda x: x.score, reverse=True)])
            def color_action(val):
                color = '#00ff88' if val == 'BUY' else '#ff4b4b'
                return f'color: {color}; font-weight: bold'
            st.dataframe(df_view.style.map(color_action, subset=['Action']), hide_index=True)
            pdf = generate_pdf(signals)
            st.download_button("üì• T√©l√©charger PDF", pdf, f"{APP_NAME.replace(' ', '_')}_Report.pdf", "application/pdf")

if __name__ == "__main__":
    main()
